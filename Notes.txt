Orm Paketleri ne işe yarar:
//SqlDataAdapter adp= new SqlDataAdapter("select * from Users", con);
//DataTable da= new DataTable();
//da.Clear();
//adp.Fill(da);

sql ile yapacağımız işlemleri daha kolay hale getirir. -> bu kodları uzun uyazmak yerine
paketler sayesinde daha kısa ve anlaşılır bir şekilde yazabiliriz.

 public class SimpleContextDb : DbContext
 dbContext sınıfı, Entity Framework Core'un temel sınıfıdır
 ve veritabanı ile etkileşim kurmak için kullanılır.
 -> database ler ile kolay bir şekilde çalışmamızı sağlar.

 //dbContext içindeki onconfig metodunu override ederek sql baplantısını yapıyoruz.

 Not:
 Entity Framework ORM yapısıyla kod kalabalığının önüne geçmiş oluruz.

             //SqlDataAdapter adp= new SqlDataAdapter("select * from Users", con);
            //DataTable da= new DataTable();
            //da.Clear();
            //adp.Fill(da);

            SimpleDbContext context = new SimpleDbContext(); ile;
            context.Users.ToList();
            -> Entity Framework tek satırda halletti!


            //Crud işlemleri için interface ' de metot imzası yapıp classlarda çağırmmaız lazım
            //DataAccess katmanında CRUD işlemleri için interface oluşturuyoruz.
            //çağırdığımız class -> Entity Framework ile CRUD işlemlerini yapacağımız class


                    public void Add(OperationClaim operationClaim)
        {
            using (var context = new SimpleContextDb())
            {
                context.OperationClaims.Add(operationClaim);
            }
        
        bu yapıda solid prensiplerini çiğnememiş oluruz.
        çünkü her class için içindeki parametre farklı yapı aynı tekrarlı!
        Generic yapı kurarak bunun önüne geçmiş oluruz.

NOT:

| Yapı                                        | Açıklama                                                                                                              |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `EfOperationClaimDal`                       | **Sadece `OperationClaim` için özel olarak yazılmıştır.** CRUD işlemleri tek bir sınıfa özel kodlanmıştır.            |
| `EfEntityRepositoryBase<TEntity, TContext>` | **Tüm entity'ler için ortak kullanılır.** Generic yapı sayesinde tekrar tekrar aynı CRUD kodunu yazmana gerek kalmaz. |

not:

✅ Generic Repository Ne Sağlar?
EfEntityRepositoryBase<TEntity, TContext> sınıfı şu faydaları sağlar:

| Özellik                         | Açıklama                                                                                                                        |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Generic**                     | Tüm entity’ler için ortak bir yapı sunar: `Product`, `User`, `OperationClaim`, `Doctor`, vs.                                    |
| **Yeniden kullanılabilirlik**   | `Add`, `Update`, `GetAll` gibi işlemleri her entity için bir daha yazmana gerek kalmaz.                                         |
| **Temizlik ve okunabilirlik**   | Kodun daha sade, bakımı daha kolay hale gelir.                                                                                  |
| **Solid prensipleriyle uyumlu** | Özellikle `Open/Closed Principle` – Genişlemeye açık, değişime kapalıdır. Yeni entity eklersin ama base class’ı değiştirmezsin. |

📌 1. IEntityRepository<T> → Tüm Entity’ler için Ortak Arayüz;
public interface IEntityRepository<T>
Burada T generic parametresidir.

Add, Delete, Update, Get, GetAll gibi temel CRUD metotları tanımlanır.

Bu sayede her entity için ayrı ayrı interface yazmana gerek kalmaz


NOT:
->Uygulaması:
using Core.DataAccess;
using Entities.Concrete;
 1. IOperationClaimDal – Arayüz (Interface)
namespace DataAccess.Abstract
{
    public interface IOperationClaimDal : IEntityRepository<OperationClaim>
    {

    }
}
📌 Açıklama:
Bu bir interface yani arayüzdür.

IOperationClaimDal, OperationClaim için veri erişim işlemlerinin sözleşmesini (contract)
tanımlar.

IEntityRepository<OperationClaim>'den kalıtım alır.

Böylece Add, Delete, Update, Get, GetAll gibi metotlar otomatik olarak burada tanımlanmış olur.

✅ Ne işe yarar?
Business katmanında EfOperationClaimDal'a doğrudan bağımlı olmak yerine IOperationClaimDal'a
bağımlı olursun. Böylece test edilebilirlik ve esneklik sağlarsın.

 2. EfOperationClaimDal – Concrete (EF Core ile uygulama)
 using Core.DataAccess.EntityFramework;
using DataAccess.Abstract;
using DataAccess.Concrete.EntityFramework.Context;
using Entities.Concrete;

namespace DataAccess.Concrete.EntityFramework
{
    public class EfOperationClaimDal : EfEntityRepositoryBase<OperationClaim, SimpleContextDb>,
    IOperationClaimDal
    {

    }
}
✅ Ne işe yarar?
EF Core kullanarak OperationClaim için veritabanı işlemlerini (Add, Delete, Update, GetAll, vs.)
gerçekleştirmeye hazır bir class'tır.

Not:
-business Crud işlemlerinin Generic yapısı yok!

🔍 Dependency Injection (DI) Nedir?
Dependency Injection, bir sınıfın bağımlı olduğu (kullanacağı) nesneleri kendi içinde oluşturmak 
yerine, dışarıdan (yani başka bir yerden) sağlamasıdır.
->ınterfacelerin hangi classlarla implemenet olduğunu söyleyen program
 Bu sayede:
Kod daha sade, test edilebilir ve esnek hale gelir.

Katmanlar arası bağımlılık azalır.

Solid prensiplerinden biri olan “Dependency Inversion Principle” uygulanmış olur.




Not:
-> Refactoring kod üzerinde düzeltme demektir!



NOT:
katmanlı mimari (Layered Architecture):
-Entities.Dtos → Veri taşıma nesneleri (DTO - Data Transfer Object)
-Business.Abstract → Servis arayüzleri (interface'ler)
-WebApi.Controllers → API'nin dış dünyaya açıldığı yer (kullanıcıdan gelen istekleri alır)

Dto neden kullanılır:
public class AuthDto
{
    public string Name { get; set; }
    public string Email { get; set; }
    public string ImageUrl { get; set; }
    public string Password { get; set; }
}
-> örneğin burada  kullanıcıdan alınan verileri geçici olarak tutmak için kullanılır. 
->ullanıcıdan gelen Register isteğinde bunlara gerek yok
. İşte bu yüzden DTO sınıfı kullanılır: sadece gerekli verilerle iletişim kurmak için.
(kullanıcıdajkiş bütün değperlere register da gerek bu yüzden GEREKLİ VERİLERLE İLETİŞİM İÇİN
kullanılır;!)
Kısaca:
| Katman                          | Görevi                                                        |
| ------------------------------- | ------------------------------------------------------------- |
| **DTO (AuthDto)**               | Kullanıcıdan alınacak bilgileri taşır                         |
| **Controller (AuthController)** | API’ye gelen isteği karşılar, DTO'yu servis katmanına iletir  |
| **Service (IAuthService)**      | İş mantığını içerir, örneğin şifreyi hashler, veriyi kaydeder |
| **Repository/DbContext**        | Veritabanı ile doğrudan iletişim kurar                        |


Not:
-> bir classın içinde metot oluşturduğumuz zaman başka bir yerden o metoda erişeceğimizde;
static yapıda olması gerekir metodun!

Not:
-> DataAccess sadece kayıt yapar bu kayıtların kontrollerini bilmez,
-> Business bu kayıttan sonraki ve önceki işlemleri yapıp ondan sonra DataAcsess e söylemek;
->UI  da istek katmanı;

Not:
Fluent validation:
 public string Register(RegisterAuthDto registerDto)
        {

            //Fluent validation
            if (registerDto.Name == "")
            return    "UserName cannot be Empty! ";

            if (registerDto.Email == "")
                return "Email cannot be Empty!";

            if (registerDto.ImageUrl == "")
                return "Image cannot be Empty!";

            if (registerDto.Password == "")
                return "Password cannot be Empty!";

            if (registerDto.Password.Length < 6)
                return "Password must be 6 character at least!";
            _userService.Add(registerDto);
            return "User Record has been completed succesfully";
        }
    }

    -> Bu şekilde doğrulama işlemlerini uzun uzun yazmak yerine fluent validation paketiyle
    daha pratik bir şekilde yapı kurabiliriz!


    Not:
    ->  public string Register(RegisterAuthDto registerDto)
        {

            //Fluent validation
           UserValidator userValidator = new UserValidator();
           ValidationResult result = userValidator.Validate(registerDto);
            if (result.IsValid)
            {
                  _userService.Add(registerDto);
                  return "User Record has been completed succesfully";
            }
            return "Please fill in the required fields";
        } bu şekilde fluent validationla tek bir hata görebiliyoruz ancak metodu,
        List yapısında yaparsak bütün hataları yakalayabiliriz!

        Not:
        ->  [AttributeUsage(AttributeTargets.Class|
        AttributeTargets.Method,AllowMultiple =true,Inherited =true)]
    public abstract class MethodInterceptionBaseAttribute
    {

    }
    -> burada şunu demek istedik : 
    C#’ta attribute yazarken çoğunlukla başına [AttributeUsage] eklenir.

    Bu, bu attribute hem class’ların hem de method’ların üzerine yazılabilir demek.
    [MyAttribute] // Class üzerine uygulanıyor
public class MyClass { }

[MyAttribute] // Method üzerine uygulanıyor
public void MyMethod() { }
 AllowMultiple = true
Bu, aynı yere bu attribute’dan birden fazla eklenebilir anlamına gelir
[MyAttribute("Log")]
[MyAttribute("Cache")]
public void MyMethod() { }
Bu, bu attribute miras alınabilir demek.
->abstract ⇒ Bu sınıf tek başına kullanılamaz, mutlaka miras alınarak kullanılmalı.


NOT:
 AOP (Aspect-Oriented Programming) yaklaşımında metodun içine girmeden
 önce veya çıktıktan sonra çalışacak ek davranışları tanımlar.

 Amacı: Metot çalışmadan önce, gelen registerDto’yu UserValidator ile doğrulamak.

typeof(UserValidator) ⇒ Buraya hangi doğrulama sınıfı kullanılacağını söylüyorsun.
Bu sınıf genellikle FluentValidation’dan türetilmiş bir sınıf olur.
Çalışma mantığı:

Metot çalıştırılmadan önce ValidationAspect devreye girer.

UserValidator kullanılarak registerDto içindeki alanlar (email, şifre vs.) kurallara uyuyor mu kontrol edilir.

Eğer kurallara uymuyorsa metot hiç çalışmadan hata döndürülür.

public class UserValidator : AbstractValidator<RegisterAuthDto>
{
    public UserValidator()
    {
        RuleFor(u => u.Email).NotEmpty().EmailAddress();
        RuleFor(u => u.Password).MinimumLength(6);
    }
}


Neden bu şekilde kullanıyoruz?
Bu yaklaşımın avantajı:

AOP sayesinde “doğrulama” ve “loglama” kodlarını her metoda tek tek yazmana gerek yok.

Metot sadece kendi işine odaklanıyor (Register ⇒ kayıt eklemek).

Yan görevler (log, validation, caching, authorization) ayrı attribute’lar olarak yönetiliyor.

Böylece temiz kod ve bakım kolaylığı sağlanıyor.

[ValidationAspect] ⇒ Metot çalışmadan önce doğrulama yapar.

[LogAspect] ⇒ Metot çalıştıktan sonra loglama yapar.
İkisi de, AOP ile MethodInterceptionBaseAttribute gibi bir taban sınıf üzerinden çalışır.


Not:
        public async Task Add(RegisterAuthDto authDto)
        {
            
            var fileFormat= authDto.Image.FileName.Substring(authDto.Image.FileName.LastIndexOf('.'));
            fileFormat = fileFormat.ToLower();
            string fileName = Guid.NewGuid().ToString() + fileFormat;

            string path = "./Content/img/" + fileName;
            using (var stream = System.IO.File.Create(path))
            {
                authDto.Image.CopyTo(stream);
            }



            byte[] passwordHash, passwordSalt;

            HashingHelper.CreatePassword(authDto.Password, out  passwordHash, out  passwordSalt);

            User user = new User();
            user.Id = 0;
            user.Email=authDto.Email;   
            user.Name=authDto.Name;
            user.PasswordHash = passwordHash;
            user.PasswordSalt = passwordSalt;
            user.ImageUrl = fileName;
            _userDal.Add(user);
        }

        -bu yapı Solid prensiplerine aykırı;
        çünkü solid prensibine göre her metodun sadece 1 tane görevi olmalıdır!


Not:
Repository Nedir?
Repository, DataAccess katmanında kullanılan bir tasarım deseni (design pattern)’dir.
Amacı:

Veritabanı erişimini soyutlamak (abstraction)

Kod tekrarını önlemek

Business katmanının SQL, EF Core, Dapper gibi teknolojilere bağımlı olmamasını sağlamak

💬 Basitçe:

Repository, veritabanı ile doğrudan konuşan bir "aracı" katmandır.
Business katmanı, “Git bana bütün kullanıcıları getir” der; repository de hangi SQL çalışacak, EF Core mu kullanılacak, bunu kendi içinde halleder.

:NOT
-> Kendi tokenımızı yazma:
 public  static  class ClaimsExtensions
    {
        public static void AddName(this ICollection<Claim> claims, string name)
        {

            claims.Add(new Claim(ClaimTypes.Name,name));
        }

        //roller için ekleme
        public static void AddRoles(this ICollection<Claim> claims, string[] roles)
        {

            roles.ToList().ForEach(roles => claims.Add(new Claim(ClaimTypes.Role, roles)));
        }
    }
} 
-Bu ClaimsExtensions sınıfı, C# Extension Method (genişletme metodu) kullanarak ICollection<Claim> tipine iki yeni yardımcı metot ekliyor:

AddName(...)

AddRoles(...)

Bunlar sayesinde JWT içine claim ekleme işlemini daha kısa ve temiz kodla yapabiliyorsun.

1️. AddName metodu.
this ICollection<Claim> claims → Bu sayede metodu claims listesi üzerinden çağırabilirsin.

İçerisine ClaimTypes.Name tipinde bir claim ekliyor.

2. AddRoles metodu


string[] roles parametresi ile gelen rol listesi üzerinde dönüyor.

Her bir rol için ClaimTypes.Role tipinde claim ekliyor.
->
var claims = new List<Claim>();
claims.AddRoles(new string[] { "Admin", "User" });
// Artık claims listesinde:
// [Type: Role, Value: "Admin"]
// [Type: Role, Value: "User"]
->var claims = new List<Claim>();
claims.AddName("Furkan Aydemir");
// Artık claims listesinde: [Type: Name, Value: "Furkan Aydemir"] var.

Nerede kullanılır?
Bu metotlar genelde JWT token üretirken claim listesi hazırlamak için kullanılır.
Örneğin TokenHandler içinde:
var claims = new List<Claim>();
claims.AddName(user.FirstName + " " + user.LastName);
claims.AddRoles(operationClaims.Select(o => o.Name).ToArray());

NOT:
public List<OperationClaim> UserOperationClaims(int UserId)
{
    using (var context = new SimpleContextDb())
    {
        var result = from UserOperationClaim in context.UserOperationClaims.Where(p => p.UserId == UserId)
                     join OperationClaim in context.OperationClaims
                     on UserOperationClaim.OperationClaimId equals OperationClaim.Id
                     select new OperationClaim
                     {
                         Id = OperationClaim.Id,
                         Name = OperationClaim.Name
                     };

        return result.OrderBy(p => p.Name).ToList();
    }
}



 Adım adım:

using (var context = new SimpleContextDb())

Yeni bir EF Core veritabanı context'i oluşturuyor (SimpleContextDb).

using bloğu bittiğinde context otomatik dispose ediliyor.

context.UserOperationClaims.Where(p => p.UserId == UserId)

UserOperationClaims tablosundan sadece ilgili kullanıcıya ait kayıtlar filtreleniyor.

Yani bu kullanıcı hangi OperationClaim id’lerine sahip, onları alıyoruz.

join OperationClaim in context.OperationClaims

Kullanıcının sahip olduğu claim ID'lerini, OperationClaims tablosuyla join ediyoruz.

Böylece claim’in sadece ID’si değil, adı (Name) gibi bilgileri de çekiyoruz.

select new OperationClaim { ... }

Sadece Id ve Name alanları doldurulmuş yeni OperationClaim nesneleri oluşturuluyor.

result.OrderBy(p => p.Name).ToList();

Rolleri isimlerine göre sıralayıp liste olarak döndürüyor.


Not:
API tarafında transaction işlemi dediğimiz şey, birden fazla veritabanı operasyonunun tek bir bütün olarak çalıştırılmasıdır.
Yani "ya hepsi başarılı olur, ya hiçbiri olmaz" mantığı.

 Neden kullanılır?
Düşün ki API’n içinde bir endpoint var ve bu endpoint:

Kullanıcı tablosuna yeni kayıt ekliyor

Kullanıcının bakiyesinden para düşüyor

Başka bir tablodaki raporu güncelliyor

Eğer bu üç işlemden bir tanesi bile hata alırsa (örneğin 2. adımda bağlantı koparsa)
ilk adımda yapılan kayıt da geri alınmalı.
İşte bunu transaction yönetiyor.

Mantık:
Transaction başlatılır (BeginTransaction)

Adım adım işlemler yapılır

Tüm adımlar başarılıysa commit edilir → değişiklikler kalıcı olur

Hata olursa rollback yapılır → sanki hiç işlem yapılmamış gibi olur

Not:
IOC NEDİR:
IoC (Inversion of Control) yazılım geliştirmede kullanılan bir tasarım prensibi.


"Nesnelerin bağımlılıklarını kendilerinin oluşturması yerine, dışarıdan verilmesi prensibi"

Yani kodun kontrol akışını sen değil, framework/kapsayıcı yönetiyor.


Not:
Casching işlemi:
-, bir metot çağrısının sonucunu önbelleğe (cache) alarak tekrar tekrar aynı işlemi
yapmak yerine önbellekten hızlıca geri döndürmek için hazırlanmış bir
altyapıyı gösteriyor. Bu, performansı artırmak ve 
gereksiz veri tabanı ya da işlem yükünü azaltmak için sık kullanılan bir tekniktir.

2. CoreModule Sınıfı — Önbellek Servisini Sisteme Enjekte Etme

public class CoreModule : ICoreModule
{
    public void Load(IServiceCollection services)
    {
        services.AddMemoryCache();
        services.AddSingleton<ICacheManager, MemoryCashManager>();
    }
}
-Bu sınıf, sistemde kullanılan servislerin konfigürasyonunu yapar.
services.AddMemoryCache() ile .NET'in MemoryCache altyapısını servislere ekler.
Bu, RAM üzerinde çalışan geçici önbellek sağlar.
services.AddSingleton<ICacheManager, MemoryCashManager>(); ile
kendi tanımladığın ICacheManager arayüzünün, MemoryCashManager isimli 
somut sınıf tarafından implemente edildiğini ve bunun singleton
(uygulama boyunca tek bir örnek) olarak kullanılacağını belirtir.

Böylece CacheAspect içinde çağrılan _cacheManager nesnesi,
MemoryCashManager üzerinden gerçek önbellek işlemlerini yapar.

Özet:
CacheAspect: Metot bazlı önbellekleme için aspect. Metot çalışmadan önce cache kontrolü yapar, varsa önbellekten döner yoksa metodu çalıştırır ve sonucu önbelleğe ekler.

CoreModule: .NET servis konteynerine MemoryCache ve CacheManager servisini ekler.

[CacheAspect(60)]: Metodun 60 dakika önbellekleme ile çalışmasını sağlar.

->Bu yapı sayesinde aynı metot aynı parametrelerle tekrar tekrar çağrıldığında 
veri tabanı veya ağır işlemler yerine
çok hızlı şekilde önbellekten sonuç alınır. Performans artar, sistem yükü azalır.