Orm Paketleri ne işe yarar:
//SqlDataAdapter adp= new SqlDataAdapter("select * from Users", con);
//DataTable da= new DataTable();
//da.Clear();
//adp.Fill(da);

sql ile yapacağımız işlemleri daha kolay hale getirir. -> bu kodları uzun uyazmak yerine
paketler sayesinde daha kısa ve anlaşılır bir şekilde yazabiliriz.

 public class SimpleContextDb : DbContext
 dbContext sınıfı, Entity Framework Core'un temel sınıfıdır
 ve veritabanı ile etkileşim kurmak için kullanılır.
 -> database ler ile kolay bir şekilde çalışmamızı sağlar.

 //dbContext içindeki onconfig metodunu override ederek sql baplantısını yapıyoruz.

 Not:
 Entity Framework ORM yapısıyla kod kalabalığının önüne geçmiş oluruz.

             //SqlDataAdapter adp= new SqlDataAdapter("select * from Users", con);
            //DataTable da= new DataTable();
            //da.Clear();
            //adp.Fill(da);

            SimpleDbContext context = new SimpleDbContext(); ile;
            context.Users.ToList();
            -> Entity Framework tek satırda halletti!


            //Crud işlemleri için interface ' de metot imzası yapıp classlarda çağırmmaız lazım
            //DataAccess katmanında CRUD işlemleri için interface oluşturuyoruz.
            //çağırdığımız class -> Entity Framework ile CRUD işlemlerini yapacağımız class


                    public void Add(OperationClaim operationClaim)
        {
            using (var context = new SimpleContextDb())
            {
                context.OperationClaims.Add(operationClaim);
            }
        
        bu yapıda solid prensiplerini çiğnememiş oluruz.
        çünkü her class için içindeki parametre farklı yapı aynı tekrarlı!
        Generic yapı kurarak bunun önüne geçmiş oluruz.

NOT:

| Yapı                                        | Açıklama                                                                                                              |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `EfOperationClaimDal`                       | **Sadece `OperationClaim` için özel olarak yazılmıştır.** CRUD işlemleri tek bir sınıfa özel kodlanmıştır.            |
| `EfEntityRepositoryBase<TEntity, TContext>` | **Tüm entity'ler için ortak kullanılır.** Generic yapı sayesinde tekrar tekrar aynı CRUD kodunu yazmana gerek kalmaz. |

not:

✅ Generic Repository Ne Sağlar?
EfEntityRepositoryBase<TEntity, TContext> sınıfı şu faydaları sağlar:

| Özellik                         | Açıklama                                                                                                                        |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Generic**                     | Tüm entity’ler için ortak bir yapı sunar: `Product`, `User`, `OperationClaim`, `Doctor`, vs.                                    |
| **Yeniden kullanılabilirlik**   | `Add`, `Update`, `GetAll` gibi işlemleri her entity için bir daha yazmana gerek kalmaz.                                         |
| **Temizlik ve okunabilirlik**   | Kodun daha sade, bakımı daha kolay hale gelir.                                                                                  |
| **Solid prensipleriyle uyumlu** | Özellikle `Open/Closed Principle` – Genişlemeye açık, değişime kapalıdır. Yeni entity eklersin ama base class’ı değiştirmezsin. |

📌 1. IEntityRepository<T> → Tüm Entity’ler için Ortak Arayüz;
public interface IEntityRepository<T>
Burada T generic parametresidir.

Add, Delete, Update, Get, GetAll gibi temel CRUD metotları tanımlanır.

Bu sayede her entity için ayrı ayrı interface yazmana gerek kalmaz


NOT:
->Uygulaması:
using Core.DataAccess;
using Entities.Concrete;
 1. IOperationClaimDal – Arayüz (Interface)
namespace DataAccess.Abstract
{
    public interface IOperationClaimDal : IEntityRepository<OperationClaim>
    {

    }
}
📌 Açıklama:
Bu bir interface yani arayüzdür.

IOperationClaimDal, OperationClaim için veri erişim işlemlerinin sözleşmesini (contract)
tanımlar.

IEntityRepository<OperationClaim>'den kalıtım alır.

Böylece Add, Delete, Update, Get, GetAll gibi metotlar otomatik olarak burada tanımlanmış olur.

✅ Ne işe yarar?
Business katmanında EfOperationClaimDal'a doğrudan bağımlı olmak yerine IOperationClaimDal'a
bağımlı olursun. Böylece test edilebilirlik ve esneklik sağlarsın.

 2. EfOperationClaimDal – Concrete (EF Core ile uygulama)
 using Core.DataAccess.EntityFramework;
using DataAccess.Abstract;
using DataAccess.Concrete.EntityFramework.Context;
using Entities.Concrete;

namespace DataAccess.Concrete.EntityFramework
{
    public class EfOperationClaimDal : EfEntityRepositoryBase<OperationClaim, SimpleContextDb>,
    IOperationClaimDal
    {

    }
}
✅ Ne işe yarar?
EF Core kullanarak OperationClaim için veritabanı işlemlerini (Add, Delete, Update, GetAll, vs.)
gerçekleştirmeye hazır bir class'tır.

Not:
-business Crud işlemlerinin Generic yapısı yok!

🔍 Dependency Injection (DI) Nedir?
Dependency Injection, bir sınıfın bağımlı olduğu (kullanacağı) nesneleri kendi içinde oluşturmak 
yerine, dışarıdan (yani başka bir yerden) sağlamasıdır.
->ınterfacelerin hangi classlarla implemenet olduğunu söyleyen program
 Bu sayede:
Kod daha sade, test edilebilir ve esnek hale gelir.

Katmanlar arası bağımlılık azalır.

Solid prensiplerinden biri olan “Dependency Inversion Principle” uygulanmış olur.




Not:
-> Refactoring kod üzerinde düzeltme demektir!



NOT:
katmanlı mimari (Layered Architecture):
-Entities.Dtos → Veri taşıma nesneleri (DTO - Data Transfer Object)
-Business.Abstract → Servis arayüzleri (interface'ler)
-WebApi.Controllers → API'nin dış dünyaya açıldığı yer (kullanıcıdan gelen istekleri alır)

Dto neden kullanılır:
public class AuthDto
{
    public string Name { get; set; }
    public string Email { get; set; }
    public string ImageUrl { get; set; }
    public string Password { get; set; }
}
-> örneğin burada  kullanıcıdan alınan verileri geçici olarak tutmak için kullanılır. 
->ullanıcıdan gelen Register isteğinde bunlara gerek yok
. İşte bu yüzden DTO sınıfı kullanılır: sadece gerekli verilerle iletişim kurmak için.
(kullanıcıdajkiş bütün değperlere register da gerek bu yüzden GEREKLİ VERİLERLE İLETİŞİM İÇİN
kullanılır;!)
Kısaca:
| Katman                          | Görevi                                                        |
| ------------------------------- | ------------------------------------------------------------- |
| **DTO (AuthDto)**               | Kullanıcıdan alınacak bilgileri taşır                         |
| **Controller (AuthController)** | API’ye gelen isteği karşılar, DTO'yu servis katmanına iletir  |
| **Service (IAuthService)**      | İş mantığını içerir, örneğin şifreyi hashler, veriyi kaydeder |
| **Repository/DbContext**        | Veritabanı ile doğrudan iletişim kurar                        |


Not:
-> bir classın içinde metot oluşturduğumuz zaman başka bir yerden o metoda erişeceğimizde;
static yapıda olması gerekir metodun!

Not:
-> DataAccess sadece kayıt yapar bu kayıtların kontrollerini bilmez,
-> Business bu kayıttan sonraki ve önceki işlemleri yapıp ondan sonra DataAcsess e söylemek;
->UI  da istek katmanı;

Not:
Fluent validation:
 public string Register(RegisterAuthDto registerDto)
        {

            //Fluent validation
            if (registerDto.Name == "")
            return    "UserName cannot be Empty! ";

            if (registerDto.Email == "")
                return "Email cannot be Empty!";

            if (registerDto.ImageUrl == "")
                return "Image cannot be Empty!";

            if (registerDto.Password == "")
                return "Password cannot be Empty!";

            if (registerDto.Password.Length < 6)
                return "Password must be 6 character at least!";
            _userService.Add(registerDto);
            return "User Record has been completed succesfully";
        }
    }

    -> Bu şekilde doğrulama işlemlerini uzun uzun yazmak yerine fluent validation paketiyle
    daha pratik bir şekilde yapı kurabiliriz!


    Not:
    ->  public string Register(RegisterAuthDto registerDto)
        {

            //Fluent validation
           UserValidator userValidator = new UserValidator();
           ValidationResult result = userValidator.Validate(registerDto);
            if (result.IsValid)
            {
                  _userService.Add(registerDto);
                  return "User Record has been completed succesfully";
            }
            return "Please fill in the required fields";
        } bu şekilde fluent validationla tek bir hata görebiliyoruz ancak metodu,
        List yapısında yaparsak bütün hataları yakalayabiliriz!

        Not:
        ->  [AttributeUsage(AttributeTargets.Class|
        AttributeTargets.Method,AllowMultiple =true,Inherited =true)]
    public abstract class MethodInterceptionBaseAttribute
    {

    }
    -> burada şunu demek istedik : 
    C#’ta attribute yazarken çoğunlukla başına [AttributeUsage] eklenir.

    Bu, bu attribute hem class’ların hem de method’ların üzerine yazılabilir demek.
    [MyAttribute] // Class üzerine uygulanıyor
public class MyClass { }

[MyAttribute] // Method üzerine uygulanıyor
public void MyMethod() { }
 AllowMultiple = true
Bu, aynı yere bu attribute’dan birden fazla eklenebilir anlamına gelir
[MyAttribute("Log")]
[MyAttribute("Cache")]
public void MyMethod() { }
Bu, bu attribute miras alınabilir demek.
->abstract ⇒ Bu sınıf tek başına kullanılamaz, mutlaka miras alınarak kullanılmalı.


NOT:
 AOP (Aspect-Oriented Programming) yaklaşımında metodun içine girmeden
 önce veya çıktıktan sonra çalışacak ek davranışları tanımlar.

 Amacı: Metot çalışmadan önce, gelen registerDto’yu UserValidator ile doğrulamak.

typeof(UserValidator) ⇒ Buraya hangi doğrulama sınıfı kullanılacağını söylüyorsun.
Bu sınıf genellikle FluentValidation’dan türetilmiş bir sınıf olur.
Çalışma mantığı:

Metot çalıştırılmadan önce ValidationAspect devreye girer.

UserValidator kullanılarak registerDto içindeki alanlar (email, şifre vs.) kurallara uyuyor mu kontrol edilir.

Eğer kurallara uymuyorsa metot hiç çalışmadan hata döndürülür.

public class UserValidator : AbstractValidator<RegisterAuthDto>
{
    public UserValidator()
    {
        RuleFor(u => u.Email).NotEmpty().EmailAddress();
        RuleFor(u => u.Password).MinimumLength(6);
    }
}


Neden bu şekilde kullanıyoruz?
Bu yaklaşımın avantajı:

AOP sayesinde “doğrulama” ve “loglama” kodlarını her metoda tek tek yazmana gerek yok.

Metot sadece kendi işine odaklanıyor (Register ⇒ kayıt eklemek).

Yan görevler (log, validation, caching, authorization) ayrı attribute’lar olarak yönetiliyor.

Böylece temiz kod ve bakım kolaylığı sağlanıyor.

[ValidationAspect] ⇒ Metot çalışmadan önce doğrulama yapar.

[LogAspect] ⇒ Metot çalıştıktan sonra loglama yapar.
İkisi de, AOP ile MethodInterceptionBaseAttribute gibi bir taban sınıf üzerinden çalışır.


Not:
        public async Task Add(RegisterAuthDto authDto)
        {
            
            var fileFormat= authDto.Image.FileName.Substring(authDto.Image.FileName.LastIndexOf('.'));
            fileFormat = fileFormat.ToLower();
            string fileName = Guid.NewGuid().ToString() + fileFormat;

            string path = "./Content/img/" + fileName;
            using (var stream = System.IO.File.Create(path))
            {
                authDto.Image.CopyTo(stream);
            }



            byte[] passwordHash, passwordSalt;

            HashingHelper.CreatePassword(authDto.Password, out  passwordHash, out  passwordSalt);

            User user = new User();
            user.Id = 0;
            user.Email=authDto.Email;   
            user.Name=authDto.Name;
            user.PasswordHash = passwordHash;
            user.PasswordSalt = passwordSalt;
            user.ImageUrl = fileName;
            _userDal.Add(user);
        }

        -bu yapı Solid prensiplerine aykırı;
        çünkü solid prensibine göre her metodun sadece 1 tane görevi olmalıdır!


Not:
Repository Nedir?
Repository, DataAccess katmanında kullanılan bir tasarım deseni (design pattern)’dir.
Amacı:

Veritabanı erişimini soyutlamak (abstraction)

Kod tekrarını önlemek

Business katmanının SQL, EF Core, Dapper gibi teknolojilere bağımlı olmamasını sağlamak

💬 Basitçe:

Repository, veritabanı ile doğrudan konuşan bir "aracı" katmandır.
Business katmanı, “Git bana bütün kullanıcıları getir” der; repository de hangi SQL çalışacak, EF Core mu kullanılacak, bunu kendi içinde halleder.