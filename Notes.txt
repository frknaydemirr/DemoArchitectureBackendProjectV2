Orm Paketleri ne işe yarar:
//SqlDataAdapter adp= new SqlDataAdapter("select * from Users", con);
//DataTable da= new DataTable();
//da.Clear();
//adp.Fill(da);

sql ile yapacağımız işlemleri daha kolay hale getirir. -> bu kodları uzun uyazmak yerine
paketler sayesinde daha kısa ve anlaşılır bir şekilde yazabiliriz.

 public class SimpleContextDb : DbContext
 dbContext sınıfı, Entity Framework Core'un temel sınıfıdır
 ve veritabanı ile etkileşim kurmak için kullanılır.
 -> database ler ile kolay bir şekilde çalışmamızı sağlar.

 //dbContext içindeki onconfig metodunu override ederek sql baplantısını yapıyoruz.

 Not:
 Entity Framework ORM yapısıyla kod kalabalığının önüne geçmiş oluruz.

             //SqlDataAdapter adp= new SqlDataAdapter("select * from Users", con);
            //DataTable da= new DataTable();
            //da.Clear();
            //adp.Fill(da);

            SimpleDbContext context = new SimpleDbContext(); ile;
            context.Users.ToList();
            -> Entity Framework tek satırda halletti!


            //Crud işlemleri için interface ' de metot imzası yapıp classlarda çağırmmaız lazım
            //DataAccess katmanında CRUD işlemleri için interface oluşturuyoruz.
            //çağırdığımız class -> Entity Framework ile CRUD işlemlerini yapacağımız class


                    public void Add(OperationClaim operationClaim)
        {
            using (var context = new SimpleContextDb())
            {
                context.OperationClaims.Add(operationClaim);
            }
        
        bu yapıda solid prensiplerini çiğnememiş oluruz.
        çünkü her class için içindeki parametre farklı yapı aynı tekrarlı!
        Generic yapı kurarak bunun önüne geçmiş oluruz.

NOT:

| Yapı                                        | Açıklama                                                                                                              |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| `EfOperationClaimDal`                       | **Sadece `OperationClaim` için özel olarak yazılmıştır.** CRUD işlemleri tek bir sınıfa özel kodlanmıştır.            |
| `EfEntityRepositoryBase<TEntity, TContext>` | **Tüm entity'ler için ortak kullanılır.** Generic yapı sayesinde tekrar tekrar aynı CRUD kodunu yazmana gerek kalmaz. |

not:

✅ Generic Repository Ne Sağlar?
EfEntityRepositoryBase<TEntity, TContext> sınıfı şu faydaları sağlar:

| Özellik                         | Açıklama                                                                                                                        |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Generic**                     | Tüm entity’ler için ortak bir yapı sunar: `Product`, `User`, `OperationClaim`, `Doctor`, vs.                                    |
| **Yeniden kullanılabilirlik**   | `Add`, `Update`, `GetAll` gibi işlemleri her entity için bir daha yazmana gerek kalmaz.                                         |
| **Temizlik ve okunabilirlik**   | Kodun daha sade, bakımı daha kolay hale gelir.                                                                                  |
| **Solid prensipleriyle uyumlu** | Özellikle `Open/Closed Principle` – Genişlemeye açık, değişime kapalıdır. Yeni entity eklersin ama base class’ı değiştirmezsin. |

📌 1. IEntityRepository<T> → Tüm Entity’ler için Ortak Arayüz;
public interface IEntityRepository<T>
Burada T generic parametresidir.

Add, Delete, Update, Get, GetAll gibi temel CRUD metotları tanımlanır.

Bu sayede her entity için ayrı ayrı interface yazmana gerek kalmaz


NOT:
->Uygulaması:
using Core.DataAccess;
using Entities.Concrete;
 1. IOperationClaimDal – Arayüz (Interface)
namespace DataAccess.Abstract
{
    public interface IOperationClaimDal : IEntityRepository<OperationClaim>
    {

    }
}
📌 Açıklama:
Bu bir interface yani arayüzdür.

IOperationClaimDal, OperationClaim için veri erişim işlemlerinin sözleşmesini (contract)
tanımlar.

IEntityRepository<OperationClaim>'den kalıtım alır.

Böylece Add, Delete, Update, Get, GetAll gibi metotlar otomatik olarak burada tanımlanmış olur.

✅ Ne işe yarar?
Business katmanında EfOperationClaimDal'a doğrudan bağımlı olmak yerine IOperationClaimDal'a
bağımlı olursun. Böylece test edilebilirlik ve esneklik sağlarsın.

 2. EfOperationClaimDal – Concrete (EF Core ile uygulama)
 using Core.DataAccess.EntityFramework;
using DataAccess.Abstract;
using DataAccess.Concrete.EntityFramework.Context;
using Entities.Concrete;

namespace DataAccess.Concrete.EntityFramework
{
    public class EfOperationClaimDal : EfEntityRepositoryBase<OperationClaim, SimpleContextDb>,
    IOperationClaimDal
    {

    }
}
✅ Ne işe yarar?
EF Core kullanarak OperationClaim için veritabanı işlemlerini (Add, Delete, Update, GetAll, vs.)
gerçekleştirmeye hazır bir class'tır.

Not:
-business Crud işlemlerinin Generic yapısı yok!

🔍 Dependency Injection (DI) Nedir?
Dependency Injection, bir sınıfın bağımlı olduğu (kullanacağı) nesneleri kendi içinde oluşturmak 
yerine, dışarıdan (yani başka bir yerden) sağlamasıdır.
->ınterfacelerin hangi classlarla implemenet olduğunu söyleyen program
 Bu sayede:
Kod daha sade, test edilebilir ve esnek hale gelir.

Katmanlar arası bağımlılık azalır.

Solid prensiplerinden biri olan “Dependency Inversion Principle” uygulanmış olur.




Not:
-> Refactoring kod üzerinde düzeltme demektir!



NOT:
katmanlı mimari (Layered Architecture):
-Entities.Dtos → Veri taşıma nesneleri (DTO - Data Transfer Object)
-Business.Abstract → Servis arayüzleri (interface'ler)
-WebApi.Controllers → API'nin dış dünyaya açıldığı yer (kullanıcıdan gelen istekleri alır)

Dto neden kullanılır:
public class AuthDto
{
    public string Name { get; set; }
    public string Email { get; set; }
    public string ImageUrl { get; set; }
    public string Password { get; set; }
}
-> örneğin burada  kullanıcıdan alınan verileri geçici olarak tutmak için kullanılır. 
->ullanıcıdan gelen Register isteğinde bunlara gerek yok
. İşte bu yüzden DTO sınıfı kullanılır: sadece gerekli verilerle iletişim kurmak için.
(kullanıcıdajkiş bütün değperlere register da gerek bu yüzden GEREKLİ VERİLERLE İLETİŞİM İÇİN
kullanılır;!)
Kısaca:
| Katman                          | Görevi                                                        |
| ------------------------------- | ------------------------------------------------------------- |
| **DTO (AuthDto)**               | Kullanıcıdan alınacak bilgileri taşır                         |
| **Controller (AuthController)** | API’ye gelen isteği karşılar, DTO'yu servis katmanına iletir  |
| **Service (IAuthService)**      | İş mantığını içerir, örneğin şifreyi hashler, veriyi kaydeder |
| **Repository/DbContext**        | Veritabanı ile doğrudan iletişim kurar                        |


Not:
-> bir classın içinde metot oluşturduğumuz zaman başka bir yerden o metoda erişeceğimizde;
static yapıda olması gerekir metodun!

Not:
-> DataAccess sadece kayıt yapar bu kayıtların kontrollerini bilmez,
-> Business bu kayıttan sonraki ve önceki işlemleri yapıp ondan sonra DataAcsess e söylemek;
->UI  da istek katmanı;

